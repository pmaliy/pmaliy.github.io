<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>JavaScript Creational Design Patterns</title>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <!-- Optional theme -->
    <!--link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css"-->
    <!-- Bootstrap Docs -->
    <link rel="stylesheet" href="http://getbootstrap.com/assets/css/docs.min.css">
    <!-- pm -->
    <link rel="stylesheet" href="../css/style.css">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="navbar navbar-static-top bs-docs-nav" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">pmaliy.github.io</a>
        </div>
        <!--div class="navbar-collapse collapse">
          <form class="navbar-form navbar-right" role="form">
            <div class="form-group">
              <input type="text" placeholder="Email" class="form-control">
            </div>
            <div class="form-group">
              <input type="password" placeholder="Password" class="form-control">
            </div>
            <button type="submit" class="btn btn-success">Sign in</button>
          </form>
          </div><!--/.navbar-collapse -->
      </div>
    </div>
    <!-- Main jumbotron for a primary marketing message or call to action -->
    <div class="jumbotron bs-docs-header">
      <div class="container">
        <h1>JavaScript Creational Design Patterns</h1>
        <p>Классы и объекты в JavaScript, паттерны проектирования и их классификация, порождающие (creational) паттерны</p>
      </div>
    </div>
    <div class="container">
      <!-- Example row of columns -->
      <div class="row">

        <div class="col-md-9" role="main">
          <div class="bs-docs-section">
            <h1 id="what-is-pattern" class="page-header">Что такое паттерн?</h1>
            <p class="lead">Паттерн (шаблон) - это реюзабельное решение, применимое к проблемам проектирования приложений, в нашем случае - при написании скриптов и приложений на JavaScript.</p>
            <img class="img-medium img-right" src="inception.jpg" />
            <h3 id="inception">Начало</h3>
            <p>В 1995 Erich Gamma, Richard Helm, Ralph Johnson и John Vlissides написали книгу "Design Patterns: Elements Of Reusable Object-Oriented Software". Авторы позже стали известны как "Банда Четырех" (Gang of Four, or GoF). С выходом книги концепт паттернов начал набирать популярность, т.к. GoF удалось подробно описать некоторые техники разработки и подводные камни, с которыми сталкиваются программисты при их применении, а также представить 23 шаблона проектирования, позволяющих избежать наступания на некоторые грабли.</p>
            <h3 id="why-patterns">Зачем оно надо?</h3>
            <ul>
              <li>Шаблоны - это проверенные решения: они обеспечивают твердые подходы к решению вопросов в разработке программного обеспечения, используя проверенные методы, которые отражают опыт и знания разработчиков, которые помогли определить их (что и делает их паттернами)</li>
              <li>Шаблоны можно легко переиспользовать: они, как правило, отражают решения-из-коробки, которые могут быть адаптированы под наши собственные потребности. Эта особенность делает их весьма надежными.</li>
              <li>Шаблоны выразительны: они имеют структуру и словарь для представленного решения, которые могут помочь элегантно описать даже довольно большие решения.</li>
            </ul>
            <p>Паттерны не являются решением сами по себе. Они скорее схема решения, реализация которого в разных средах лежит на разработчиках.</p>
            <h3 id="no-thanks">Можно и без паттернов обойтись</h3>
            <p>Нет, нельзя. Мы уже юзаем паттерны каждый день: кросбраузерные селекторы jQuery, IIFE (немедленно выполняемые функции), прототипирование JavaScript Object и многое другое - всё это паттерны проектирования. Некоторые из них мы используем, даже не зная о том, что это паттерны - просто это лучшее (а иногда и единственное) решение задачи.</p>
          </div>
          <div class="bs-docs-section">
            <h1 id="patterns-categories" class="page-header">Категории паттернов проектирования</h1>
            <p class="lead">В книге GoF описано 23 паттерна проектирования. В настоящее время, спустя почти 20 лет, их количество огромно, и потому деление паттернов на категории абсолютно необходимо.</p>
            <h3 id="how-to">Принцип деления</h3>
            <p>Каждый шаблон фокусируется на конкретной проблеме проектирования объектно-ориентированного приложения. Он описывает, когда он применим, может ли он быть применен при прочих условиях, а также последствия его использования и необходимые компромиссы. Таким образом, категории паттернов, используемых для решения задач проектирования, перекликаются с категориями этих задач.</p>
            <h3 id="creational">Creational Design Patterns</h3>
            <p>Порождающие паттерны предназначены для контроля механизмов инстанцирования объектов. Их использование позволяет сделать этот процесс максимально адекватным конкретной ситуации, в которой мы работаем. К этой категории относятся паттерны Constructor, Factory, Abstract, Prototype, Singleton and Builder.</p>
            <img class="img-medium img-right" src="captaino.jpg" />
            <h3 id="structural">Structural Design Patterns</h3>
            <p>Структурирующие шаблоны призваны организовывать взаимоотношения между объектами. Они помогают организовать систему так, что, когда одна из ее частей меняется, это не означает что измениться должна вся система. Это обеспечивает слабую связанность (dependency) компонентов приложения, "модульность". Представителями этой категории являются Decorator, Facade, Flyweight, Adapter and Proxy.</p>
            <h3 id="behavioral">Behavioral Design Patterns</h3>
            <p>Поведенческие паттерны применяются для улучшения механизмов коммуникации объектов между собой. В отличие от структурирующих паттернов, которые определяют положение объектов в сиситеме, паттерны поведения определяют (что бы вы думали?) их поведение. Такими шаблонами являются Iterator, Mediator, Observer и Visitor.</p>
          </div>
          <div class="bs-docs-section">
            <h1 id="js-basics" class="page-header">Прежде чем перейти к собственно паттернам...</h1>
            <p class="lead">Паттерны проектирования объектно-ориентированных приложений, как и сами эти приложения, строятся на концепте классов и их объектов (To the rescue!). В JavaScript, как мы знаем, классов нет. Не то чтобы это привело к фундаментальным отличиям JavaScript-шаблонов, но не помешает вернуться к основам, прежде чем нырнуть в кроличью нору.</p>
            <h3 id="js-classes">Классы в JavaScript</h3>
            <p>Классы можно "симулировать" с помощью функций:</p>
            <pre>
function Product(prefix) {

  this.prefix_ = prefix;
  this.type_ = "";

  this.setType = function(newType) {
    this.type_ = newType;
  };

  this.type = function() {
    return this.prefix_ + ": " + this.type_;
  };

}</pre>
            <h3 id="js-objects">Объекты в JavaScript</h3>
            <p>Объект класса может быть создан с помощью ключевого слова "new":</p>
            <pre>
var product = new Product("fruit");
product.setType("apple");
console.log( product.type() );  // fruit: apple</pre>
            <p>Также можно определить так называемый object literal:</p>
            <pre>var obj = {};</pre>
            <p>...и объект на основе прототипа:</p>
            <pre>Object.create( Object.prototype );</pre>
            <p>Существует 4 способа задать объекту свойства и методы:</p>
            <pre>
// ECMAScript 3 compatible approaches
 
// 1. Dot syntax

// Set properties
newObject.someKey = "Hello World";

// Get properties
var value = newObject.someKey;



// 2. Square bracket syntax
 
// Set properties
newObject["someKey"] = "Hello World";
 
// Get properties
var value = newObject["someKey"];
 
 
 
// ECMAScript 5 only compatible approaches
// For more information see: http://kangax.github.com/es5-compat-table/
 
// 3. Object.defineProperty
 
// Set properties
Object.defineProperty( newObject, "someKey", {
  value: "for more control of the property's behavior",
  writable: true, // false by default - разрешено ли изменять свойство
  enumerable: true, // false by default - является ли свойство перечислимым
  configurable: true // false by default - можно ли переопределить свойство
});
 

// 4. Object.defineProperties
 
// Set properties
Object.defineProperties( newObject, {
 
  "someKey": {
    value: "Hello World",
    writable: true
  },
 
  "anotherKey": {
    value: "Foo bar",
    writable: false
  }
 
});
 
// Getting properties for 3. and 4. can be done using any of the
// options in 1. and 2.</pre>
            <h3 id="get-set">Getters and setters в JavaScript</h3>
            <p>Мало кто знает об их существовании, поэтому обычно мы используем самописные методы. Переписав класс Product с их использованием, получим такой код:</p>
            <pre>
function Product(prefix) {

  this.prefix_ = prefix;
  this.type_ = "";

}

Product.prototype = {

    get type () {
      return this.prefix_ + ": " + this.type_;
    },

    set type (newType) {
      this.type_ = newType;
    }

};

var product = new Product("fruit");

product.type = "apple";
console.log(product.type); // "fruit: apple"

console.log(product.type = "orange");  // "orange"
console.log(product.type); // "fruit: orange"</pre>
            <h3 id="define-property">Object.defineProperty</h3>
            <p>В предыдущем примере я определил методы не в "классе", а на его прототипе. Забегая вперед - это один из паттернов, которые мы далее рассмотрим подробнее. Как вы можете видеть, я присвоил прототипу класса object literal, что в принципе нормально, но при таком подходе мы не сможем получить цепочку прототипирования (JavaScript-вариант наследования). Для того, чтобы обойтись без object literal, используется вышеупомянутый defineProperty:</p>
            <pre>
function Product(prefix) {

  this.prefix_ = prefix;
  this.type_ = "";

}

Object.defineProperty(Product.prototype, "type", {

  get: function () {
      return this.prefix_ + ": " + this.type_;
  },

  set: function (newType) {
    this.type_ = newType;
  }

});</pre>
            <p>Третий аргумент defineProperty называется дескриптором свойства и позволяет контролировать его доступность:</p>
            <pre>
var obj = {
    foo: "bar",
};


//A normal object property
console.log(obj.foo); //logs "bar"

obj.foo = "foobar";
console.log(obj.foo); //logs "foobar"

delete obj.foo;
console.log(obj.foo); //logs undefined


Object.defineProperty(obj, "foo", {
    value: "bar",
});

console.log(obj.foo); //logs "bar", we were able to modify foo

obj.foo = "foobar";
console.log(obj.foo); //logs "bar", write failed silently

delete obj.foo;
console.log(obj.foo); //logs bar, delete failed silently</pre>
            <p>В strict mode две последние попытки изменить свойство foo будут являться JavaScript errors.</p>
            <pre>
var obj = {};

Object.defineProperty(obj, "foo", {
    value: "bar",
    writable: true
});

console.log(obj.foo); //logs "bar"
obj.foo = "foobar";
console.log(obj.foo); //logs "foobar"</pre>
            <p>writable: true позволяет менять значение свойства.</p>
            <pre>
var obj = {};

Object.defineProperty(obj, "foo", {
    value: "bar",
});


Object.defineProperty(obj, "foo", {
    value: "foobar",
});

// Uncaught TypeError: Cannot redefine property: foo </pre>
            <p>configurable: false (по умолчанию) запрещает переопределение свойства через новый вызов Object.defineProperty. Если writable: false, но configurable: true, то это возможно.</p>
            <pre>
var i, inventory;

inventory = {
    "apples": 10
};

Object.defineProperty(inventory, "oranges", {
    value: 13
});

Object.defineProperty(inventory, "strawberries", {
    value: 3,
    enumerable: true
});

for (i in inventory) {
    console.log(i, inventory[i]);
}

console.log(inventory.propertyIsEnumerable("apples")); //logs true
console.log(inventory.propertyIsEnumerable("oranges")); //logs false
console.log(inventory.propertyIsEnumerable("strawberries")); //logs true
</pre>
            <p>Как следует из предыдущего примера, enumerable: true делает свойство перечислимым.</p>
            <p>Тот факт, что в JavaScript массив является объектом, позволяет привести еще один яркий пример на эту тему:</p>
            <pre>
var arr = [3,4,9,7];
Object.getOwnPropertyNames(arr); // все свойства
Object.keys(arr); // только перечислимые свойства</pre>
            <p>Основы повторили, перейдем к основной теме.</p>
            <img class="img-medium" src="get-down.jpg" />
          </div>
          <div class="bs-docs-section">
            <h1 id="patterns-creational" class="page-header">Creational Design Patterns</h1>
            <p class="lead">Как мы уже выяснили, порождающие шаблоны предназначены для решения проблем, связанных с контролем за созданием объектов. Мы рассмотрим следующие паттерны:</p>
            <ul class="lead">
              <li>Constructor - всегда создает объект определенного типа</li>
              <li>Singleton - класс с единственным инстансом и глобальной точкой доступа</li>
              <li>Prototype - инициализированный инстанс, который можно использовать для копирования или клонирования</li>
              <li>Factory Method - создает инстанс указанного класса на основе некоторых событий или переданных данных</li>
              <li>Abstract Factory - создает объект одного из набора классов без указания конкретного класса</li>
            </ul>
            <h3 id="constructor">Constructor Pattern</h3>
            <p><img class="img-medium" src="constructor.jpg" /></p>
            <p>Этот паттерн создает объекты класса. Всё. Да, и это всё.</p>
            <pre>
function Car( model, year, miles ) {
 
  this.model = model;
  this.year = year;
  this.miles = miles;
 
  this.toString = function () {
    return this.model + " has done " + this.miles + " miles";
  };
}
 
var civic = new Car( "Honda Civic", 2009, 20000 );
var focus = new Car( "Ford Focus", 2010, 5000 );
 
console.log( civic.toString() );
console.log( focus.toString() );</pre>
            <p>И да, мы это уже обсуждали чуть ранее. Что тут скажешь... Помните, я утверждал, что мы уже юзаем паттерны каждый день? :)</p>
            <p>Также мы обсуждали, что для определения свойств и методов, общих для всех объектов, лучше использовать prototype:</p>
            <pre>
function Car( model, year, miles ) {
 
  this.model = model;
  this.year = year;
  this.miles = miles;
 
}
  
Car.prototype.toString = function () {
  return this.model + " has done " + this.miles + " miles";
};
 
var civic = new Car( "Honda Civic", 2009, 20000 );
var focus = new Car( "Ford Focus", 2010, 5000 );
 
console.log( civic.toString() );
console.log( focus.toString() );</pre>
            <p>В этом случае метод toString не переопределяется для каждого объекта, созданного с использованием конструктора Car. Profit! Мы еще вернемся к этому вопросу, когда доберемся до Prototype Pattern.</p>
            <h3 id="singleton">Singleton Pattern</h3>
            <img class="img-medium img-right" src="singleton.jpg" />
            <p>"Singleton" буквально переводится как "одиночка; вещь, не имеющая пары". Класс, построенный с помощью данного паттерна, ограничивает количество своих объектов до одного.</p>
            <pre>
var mySingleton = (function () {
 
  // Instance stores a reference to the Singleton
  var instance;
 
  function init() {
 
    // Singleton
 
    // Private methods and variables
    function privateMethod(){
        console.log( "I am private" );
    }
 
    var privateVariable = "Im also private";
 
    var privateRandomNumber = Math.random();
 
    return {
 
      // Public methods and variables
      publicMethod: function () {
        console.log( "The public can see me!" );
      },
 
      publicProperty: "I am also public",
 
      getRandomNumber: function() {
        return privateRandomNumber;
      }
 
    };
 
  };
 
  return {
 
    // Get the Singleton instance if one exists
    // or create one if it doesn't
    getInstance: function () {
 
      if ( !instance ) {
        instance = init();
      }
 
      return instance;
    }
 
  };
 
})();</pre>
            <p>Как следует из данного примера, синглтон возвращает не класс и не объект класса, а некую структуру, содержащую public свойства и методы. На самом деле, здесь используется еще один паттерн JavaScript, известный как Module Pattern, для отделения приватных аттрибутов класса от публичных, но это тема отдельной презентации (а то и пяти).</p>
            <p>Для того чтобы получить объект синглтона нам не нужно использовать "new": глобальной точкой доступа является метод MySingleton.getInstance().</p>
            <p>В книге GoF ситуация, в которой может быть применен данный паттерн, описана так:</p>
            <ul>
              <li>Класс должен иметь единственный инстанс, и он должен быть доступен для всех клиентов через известную точку доступа</li>
              <li>Инстанс класса должен быть расширяемым, и клиенты должны иметь возможность получить расширенную версию инстанса без модификации их кода</li>
            </ul>
            <p>Во втором пункте описан вариант, когда нам может понадобиться код типа такого:</p>
            <pre>
mySingleton.getInstance = function(){
  if ( this._instance == null ) {
    if ( isFoo() ) {
       this._instance = new FooSingleton();
    } else {
       this._instance = new BasicSingleton();
    }
  }
  return this._instance;
};</pre>
            <p>Здесь getInstance становится похожим на Factory метод, благодаря чему мы не должны обновлять каждую строку кода, в которой происходит обращение к нему: FooSingleton будет расширением класса BasicSingleton с таким же интерфейсом.</p>
            <img class="img-medium img-right" src="prototype.jpg" />
            <h3 id="prototype">Prototype Pattern</h3>
            <p>Паттерн "прототип" делает возможным создание объектов на основе других, уже существующих объектов.</p>
            <p>Прототипирование как таковое не подразумевает использования классов. Тех самых классов, которых в JavaScript вообще нет. По сути мы просто создаем копии уже функционирующих объектов, которые могли быть созданы с использованием любого другого порождающего паттерна.</p>
            <p>В отличие от классов, JavaScript поддерживает прототипы нативно, и это пожалуй единственный случай, когда нам не нужно имитировать фичи других языков.</p>
            <pre>
var myCar = {
 
  name: "Ford Escort",
 
  drive: function () {
    console.log( "Weeee. I'm driving!" );
  },
 
  panic: function () {
    console.log( "Wait. How do you stop this thing?" );
  }
 
};
 
// Use Object.create to instantiate a new car
var yourCar = Object.create( myCar );
 
// Now we can see that one is a prototype of the other
console.log( yourCar.name );</pre>
            <p>Object.create создает объект, прототипом которого является первый аргумент этого метода. Второй аргумент, optionalDescriptorObjects, может содержать дескрипторы свойств, которые получит новый объект помимо унаследованных от прототипа.</p>
            <pre>
var vehicle = {
  getModel: function () {
    console.log( "The model of this vehicle is.." + this.model );
  }
};
 
var car = Object.create(vehicle, {
 
  "id": {
    value: MY_GLOBAL.nextId(),
    // writable:false, configurable:false by default
    enumerable: true
  },
 
  "model": {
    value: "Ford",
    enumerable: true
  }
 
});</pre>
            <p>Использование Prototype может дать хороший выигрыш в производительности аппликейшена: как уже отмечалось ранее, определение метода на прототипе означает, что все объекты на его основе будут использовать один и тот же метод, вместо того чтобы создавать свою собственную копию.</p>
            <p>Организовать прототипирование можно и без Object.create:</p>
            <pre>
var vehiclePrototype = {
 
  init: function ( carModel ) {
    this.model = carModel;
  },
 
  getModel: function () {
    console.log( "The model of this vehicle is.." + this.model);
  }
};
 
 
function vehicle( model ) {
 
  function F() {};
  F.prototype = vehiclePrototype;
 
  var f = new F();
 
  f.init( model );
  return f;
 
}
 
var car = vehicle( "Ford Escort" );
car.getModel();</pre>
            <p>Правда, в этом случае мы теряем возможность задавать read-only свойства, и вообще этот способ жутко похож на Сonstructor. Тем не менее, можно произвести еще один апгрейд, избавившись от hardcoded прототипа:</p>
            <pre>
var beget = (function () {
 
    function F() {}
 
    return function ( proto ) {
        F.prototype = proto;
        return new F();
    };
})();</pre>
            <p>Коротко и со вкусом. Что же касается read-only свойств - в конце концов, всегда можно запечатать (или вообще заморозить) полученный объект, получив нужный эффект на выходе (Object.preventExtensions, Object.seal, Object.freeze - обсудим это после презентации, если будет время и желание).</p>
            <img class="img-medium img-right" src="factory.jpg" />
            <h3 id="factory">Factory Pattern</h3>
            <p>Factory принципиально отличается от других порождающих паттернов тем, что не требует от нас явного использования конструктора. Вместо этого, Фабрика предоставляет интерфейс для создания объектов, в котором мы можем указать тип создаваемого объекта.</p>
            <p>Когда юзать фабрику:</p>
            <ul>
              <li>Когда настройка объекта отличается высокой сложностью</li>
              <li>Когда нужно легко генерировать различные инстансы объектов в зависимости от текущего окружения</li>
              <li>Когда мы работаем с большим количеством мелких объектов с общими свойствами</li>
              <li>Когда комбинируем объекты с инстансами других объектов, которые требуют только выполнения API-контракта (утиная типизация; уменьшает связанность)</li>
            </ul>
            <pre>
// Types.js - Constructors used behind the scenes
 
// A constructor for defining new cars
function Car( options ) {
 
  // some defaults
  this.doors = options.doors || 4;
  this.state = options.state || "brand new";
  this.color = options.color || "silver";
 
}
 
// A constructor for defining new trucks
function Truck( options){
 
  this.state = options.state || "used";
  this.wheelSize = options.wheelSize || "large";
  this.color = options.color || "blue";
}
 
 
// FactoryExample.js
 
// Define a skeleton vehicle factory
function VehicleFactory() {}
 
// Define the prototypes and utilities for this factory
 
// Our default vehicleClass is Car
VehicleFactory.prototype.vehicleClass = Car;
 
// Our Factory method for creating new Vehicle instances
VehicleFactory.prototype.createVehicle = function ( options ) {
 
  switch(options.vehicleType){
    case "car":
      this.vehicleClass = Car;
      break;
    case "truck":
      this.vehicleClass = Truck;
      break;
    //defaults to VehicleFactory.prototype.vehicleClass (Car)
  }
 
  return new this.vehicleClass( options );
 
};
 
// Create an instance of our factory that makes cars
var carFactory = new VehicleFactory();
var car = carFactory.createVehicle( {
            vehicleType: "car",
            color: "yellow",
            doors: 6 } );
 
// Test to confirm our car was created using the vehicleClass/prototype Car
 
// Outputs: true
console.log( car instanceof Car );
 
console.log( car );</pre>
            <p>Создание Truck с помощью VehicleFactory:</p>
            <pre>
var movingTruck = carFactory.createVehicle( {
                      vehicleType: "truck",
                      state: "like new",
                      color: "red",
                      wheelSize: "small" } );
 
// Test to confirm our truck was created with the vehicleClass/prototype Truck
 
// Outputs: true
console.log( movingTruck instanceof Truck );
 
console.log( movingTruck );</pre>
            <p>Создание фабрики траков на основе VehicleFactory:</p>
            <pre>
function TruckFactory () {}
TruckFactory.prototype = new VehicleFactory();
TruckFactory.prototype.vehicleClass = Truck;
 
var truckFactory = new TruckFactory();
var myBigTruck = truckFactory.createVehicle( {
                    state: "omg..so bad.",
                    color: "pink",
                    wheelSize: "so big" } );
 
// Confirms that myBigTruck was created with the prototype Truck
// Outputs: true
console.log( myBigTruck instanceof Truck );
 
console.log( myBigTruck );</pre>
            <img class="img-medium img-right" style="width: 250px;" src="dark-side.jpg" />
            <p>Когда <span style="text-decoration:underline; font-weight: bold;">не</span> юзать фабрику? Когда процесс создания объектов и без нее достаточно прост. Темная сторона силы данного паттерна заключается в том, что он сильно усложняет простые приложения (в то время как, будучи на светлой стороне, без печенек, значительно упрощает приложения сложные).</p>
            <p>Итого, если предоставление интерфейса для создания объектов не является целью библиотеки/фреймворка, лучше использовать другие порождающие паттерны.</p>
            <h3 id="abstract-factory">Abstract Factory Pattern</h3>
            <p>В примере для Фабрики VehicleFactory мы "хардкодили" два типа объектов, которые она может возвращать. Абстрактная фабрика позволяет регистрировать типы объектов, которые она может создавать, на лету:</p>
            <pre>
var abstractVehicleFactory = (function () {
 
  // Storage for our vehicle types
  var types = {};
 
  return {
      getVehicle: function ( type, customizations ) {
          var Vehicle = types[type];
 
          return (Vehicle ? new Vehicle(customizations) : null);
      },
 
      registerVehicle: function ( type, Vehicle ) {
          var proto = Vehicle.prototype;
 
          // only register classes that fulfill the vehicle contract
          if ( proto.drive && proto.breakDown ) {
              types[type] = Vehicle;
          }
 
          return abstractVehicleFactory;
      }
  };
})();
 
 
// Usage:
 
abstractVehicleFactory.registerVehicle( "car", Car );
abstractVehicleFactory.registerVehicle( "truck", Truck );
 
// Instantiate a new car based on the abstract vehicle type
var car = abstractVehicleFactory.getVehicle( "car" , {
            color: "lime green",
            state: "like new" } );
 
// Instantiate a new truck in a similar manner
var truck = abstractVehicleFactory.getVehicle( "truck" , {
            wheelSize: "medium",
            color: "neon yellow" } );</pre>
            <p>Таким образом, абстрактная фабрика группирует несколько фабрик со схожими целями. Этот паттерн <span style="text-decoration:line-through;">можно</span> нужно использовать в ситуации, когда фабрика должна быть независима от способа создания объектов, которые она генерирует, или она должна будет работать с динамическим набором конструкторов объектов.</p>
          </div>
          <div class="bs-docs-section">
            <h1 id="conclusion" class="page-header">Заключение</h1>
            <p class="lead">Порождающие шаблоны - это, безусловно, то, с чего стоит начать знакомство с JavaScript Design Patterns.</p>
            <p>При подготовке презентации я в основном использовал одноименную книгу, доступную в онлайн: <a href="http://addyosmani.com/resources/essentialjsdesignpatterns/book">JavaScript Design Patterns</a> (из нее я внаглую скопипастил почти все примеры). Отличное чтиво и для js-ninja, и для новичка. Материал в ней постоянно освежается, рассмотрено огромное количество плагинов/фреймворков в качестве примеров реализации тех или иных паттернов, присутствует список литературы (почти 40 дополнительных источников инфы). Must-read, IMHO.</p>
            <p>Также мне очень пригодилась замечательная статья <a href="http://bjorn.tipling.com/advanced-objects-in-javascript">Advanced objects in JavaScript</a> - поначалу я хотел сделать ее контент темой всей презентации, но отказался от этой мысли т.к. многое вы уже скорее всего знаете.</p>
            <p></p>
            <p style="text-align: center;"><img src="yes-we-made-it.jpg" /></p>
            <p class="lead" style="text-align: center;">На этом у меня всё, спасибо за внимание :)</p>
          </div>
        </div>

        <div class="col-md-3">
          <div class="bs-docs-sidebar hidden-print hidden-xs hidden-sm" role="complementary">
            <ul class="nav bs-docs-sidenav">
              <li>
                <a href="#what-is-pattern">Что такое паттерн?</a>
                <ul class="nav">
                  <li><a href="#inception">Начало</a></li>
                  <li><a href="#why-patterns">Зачем оно надо?</a></li>
                  <li><a href="#no-thanks">Можно и без паттернов обойтись</a></li>
                </ul>
              </li>
              <li>
                <a href="#patterns-categories">Категории паттернов проектирования</a>
                <ul class="nav">
                  <li><a href="#inception">Принцип деления</a></li>
                  <li><a href="#creational">Creational Design Patterns</a></li>
                  <li><a href="#structural">Structural Design Patterns</a></li>
                  <li><a href="#behavioral">Behavioral Design Patterns</a></li>
                </ul>
              </li>
              <li>
                <a href="#js-basics">Прежде чем перейти к собственно паттернам...</a>
                <ul class="nav">
                  <li><a href="#js-classes">Классы в JavaScript</a></li>
                  <li><a href="#js-objects">Объекты в JavaScript</a></li>
                  <li><a href="#get-set">Getters and setters в JavaScript</a></li>
                  <li><a href="#define-property">Object.defineProperty</a></li>
                </ul>
              </li>
              <li>
                <a href="#patterns-creational">Creational Design Patterns</a>
                <ul class="nav">
                  <li><a href="#constructor">Constructor Pattern</a></li>
                  <li><a href="#singleton">Singleton Pattern</a></li>
                  <li><a href="#prototype">Prototype Pattern</a></li>
                  <li><a href="#factory">Factory Pattern</a></li>
                  <li><a href="#abstract-factory">Abstract Factory Pattern</a></li>
                </ul>
              </li>
              <li>
                <a href="#conclusion">Заключение</a>
              </li>
            </ul>
            <a class="back-to-top" href="#top">
            Back to top
            </a>
          </div>
        </div>

      </div>
      <hr>
      <footer>
        <p>&copy; pmaliy 2014</p>
      </footer>
    </div>
    <!-- /container -->
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>

    <script src="http://getbootstrap.com/assets/js/docs.min.js"></script>
  </body>
</html>
